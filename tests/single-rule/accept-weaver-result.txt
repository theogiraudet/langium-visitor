/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { TestAstType } from './ast.js';
import * as InterfaceAST from './ast.js';
import * as ClassAST from './test-visitor.js';
import { TestVisitor } from './test-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof TestAstType]?: (node: TestAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class TestAcceptWeaver {
    
    private readonly checks: Weaver = {
        Model: this.weaveModel
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveModel(node : InterfaceAST.Model) : void {
        (<any> node).accept = (visitor: TestVisitor) => { return visitor.visitModel(node as unknown as ClassAST.Model); }
    }
    
}